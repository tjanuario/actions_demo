name: "terraform"
# This workflow expects will run automatically when a PR is created, updated, or synchronized
# OR when manually triggered by "terraform plan" / "terraform apply" issue comments.
# It first determines the (Terraform) files that have been modified, creates a matrix of
# corresponding Terraform root module directories (workspaces), and runs the terraform plan
# and/or apply cycle operations for each root module that has been added/changed.

on: 
  pull_request:
    branches: [ main ]
    types: [opened, synchronize, reopened]
    paths:
      - "Terraform/**"
  issue_comment:
    types: [created]

 
jobs: 
  # This job executes terraform init, fmt, validate, and plan when a PR is created
  # and on subsequent commits to the same PR branch. This workflow detects file changes
  # and only runs when ".tf" files within the workspace have been modified.
  
  manual_tf_run:
    name: "manual_tf_run"
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'issue_comment' }}
    strategy:
      fail-fast: false
      #max-parallel: 256
      matrix: 
        terraform_roots: ["this", "that"]
    steps:
      - name: Determine Command
        id: determine-command
        uses: actions/github-script@v3
        env:
          TF_ROOT: ${{ matrix.terraform_roots }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            console.log(context)            
            const body = context.payload.comment.body.toLowerCase().trim()
            console.log("Detected PR comment: " + body)
            console.log("This job is for workspace " + process.env.TF_ROOT)
            commandArray = body.split(/\s+/)
            if (commandArray[0] == "terraform") {
              action = commandArray[1]
              console.log(`action: ${commandArray[1]}`)
              switch(action) {
                case "apply":
                  if (typeof commandArray[2] === 'undefined') {
                    console.log("::set-output name=do_apply::true");
                  } else if (commandArray[2] == process.env.TF_ROOT.toLowerCase()) {
                    console.log("::set-output name=do_apply::true");
                  } else {
                    console.log("apply command is not for this Terraform root");
                  }
                  break;
                case "plan":
                  if (typeof commandArray[2] === 'undefined') {
                    console.log("::set-output name=do_plan::true")
                  } else if (commandArray[2] == process.env.TF_ROOT.toLowerCase()) {
                    console.log("::set-output name=do_plan::true")
                  } else {
                    console.log("plan command is not for this Terraform root")
                  }
                  break;
                case "force-unlock":
                  if (typeof commandArray[2] === 'undefined' || typeof commandArray[3] === 'undefined') {
                    console.log("force-unlock command must have lock-id and Terraform root")                    
                  }                   
                  else if (commandArray[3] == process.env.TF_ROOT.toLowerCase()) {
                    console.log(`lock-id: ${commandArray[3]}`)
                    console.log("::set-output name=state_lock_id::${commandArray[3]}")
                    console.log("::set-output name=do_unlock::true")
                  } 
                  else {
                    console.log("force-unlock command is not for this Terraform root")
                  }
                  break
                default:
                  console.log("Only plan, apply, and force-unlock supported for terraform. Job will not continue.")
                  break
              }
            } 
            else {
              console.log("Detected non-applicable command. Job will not continue.")
            }
          
